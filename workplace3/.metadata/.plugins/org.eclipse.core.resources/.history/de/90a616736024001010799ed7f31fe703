#include "xil_printf.h"
#include "stdbool.h"
#include "stdint.h"
#include "stdlib.h"

#define DELAY_UNIT 80
#define LEDS    (*(unsigned volatile *) 0x40000000)
#define SW      (*(unsigned volatile *) 0x40000008)

#define DPSEG   (*(unsigned volatile *) 0x40020000)
#define AN      (*(unsigned volatile *) 0x40020008)
#define btn_X   (*(unsigned volatile *) 0x40030000)





#define ALARM_COUNTER (*( volatile unsigned *) 0x44a00000)
#define ALARM0 (*(volatile unsigned *) 0x44a00004)
#define ALARM0_VALUE (*(volatile unsigned *) 0x44a00008)
#define JB   (*(volatile unsigned  *) 0x40010000)

#define JC34 (*(volatile unsigned *)0x44A20000)
#define COUNTER (*(volatile unsigned *)0x44A20004)
#define AB (*(volatile unsigned *)0x44A20008)

#define ONE_US 100
#define ONE_MS 100*1000

#define btnU 0
#define btnD 1
#define btnR 2
#define btnL 3




void delay_ms(unsigned t)
{
    unsigned cntr1, cntr2;
    while(t--){
        for(cntr1=0;cntr1<100;cntr1++){
            for(cntr2=0;cntr2<DELAY_UNIT;cntr2++){}
        }
    }
}


void delay_ms2(uint32_t val){
	ALARM0_VALUE = ONE_MS * val;
	while((ALARM0 & (1<<0))==0){
	}
}


void delay_us(uint32_t val){
	ALARM0_VALUE = ONE_US * val;
	while((ALARM0 & (1<<0))==0){

	}

}


_Bool btn_pressed(int x){
    static enum {NOT_PRESSED, DEBOUNCE_PRESS, PRESSED, DEBOUNCE_RELEASE} state[4] = {NOT_PRESSED, NOT_PRESSED, NOT_PRESSED, NOT_PRESSED};
    static uint8_t counter[4] = {0,0,0,0};
    _Bool retval = false;
    _Bool B = (btn_X & (1 << x)) != 0;

    switch(state[x]) {
    	case NOT_PRESSED:
			if(B){
				counter[x] = 0;
				state[x] = DEBOUNCE_PRESS;
			}
        break;
		case DEBOUNCE_PRESS:
			if(B){
				if(counter[x]<5) {
					counter[x]++;
				} else {
					retval = true;
					state[x] = PRESSED;
				}
			} else {
				state[x] = NOT_PRESSED;
			}
			break;
		case PRESSED:
			if(!B){
				counter[x] = 0;
				state[x] = DEBOUNCE_RELEASE;
			}
			break;
		case DEBOUNCE_RELEASE:
			if(!B){
				if(counter[x]<5) {
					counter[x]++;
				} else {
					state[x] = NOT_PRESSED;
				}
			} else {
				state[x] = PRESSED;
			}
			break;
    }
    return retval;
}



// Example 7-segment LUT for a certain hardware wiring.
// Make sure these bit patterns match your actual display (which segment is which bit).
static const uint8_t disp_lut[15] = {
  // a b c d e f g  (bit 7 typically for decimal point)
  // The code below is for a particular Pmod7-seg style device.
  // You may need to invert or shuffle bits based on your hardware.
  0b1000000, // 0
  0b1111001, // 1
  0b0100100, // 2
  0b0110000, // 3
  0b0011001, // 4
  0b0010010, // 5
  0b0000010, // 6
  0b1111000, // 7
  0b0000000, // 8
  0b0010000,  // 9
  0b1000111, // L  10
  0b0101111, // r  11
  0b1000110, // C  12
  0b1000001, //U    13
  0b1110111 // underscore 14;
};

#define L 10
#define r 11
#define C 12
#define U 13
#define underscore 14


void pulse_generator_LEFT(int duty_cycle){
    static uint16_t state=0;
    uint16_t duty = duty_cycle * 10;
    if(state<duty){
    	JB|= (1<<0);

    }
    if(state>duty){
    	JB&= ~(1<<0);
    }
    if(++state==1000){
        state=0;
    }
}

void pulse_generator_RIGHT(int duty_cycle){
    static uint16_t state=0;
    uint16_t duty = duty_cycle * 10;
    if(state<duty){
    	JB|= (1<<1);

    }
    if(state>duty){
    	JB&= ~(1<<1);
    }
    if(++state==1000){
        state=0;
    }
}

static uint8_t data[4] = {0,14,0,0};
static unsigned counter_LEFT = 0;
static unsigned counter_RIGHT = 0;

static unsigned LEFT_VALUE;
static unsigned RIGHT_VALUE;
static uint8_t record_counter=0;

unsigned estimating_width_LEFT(_Bool prev, _Bool current){
	static enum {IDLE, ESTIMATING} state = IDLE;
	_Bool rising_edge = (prev == 0 && current==1);
	_Bool falling_edge = ((prev == 1 && current==0));
	switch(state){
		case IDLE:
			counter_LEFT=0;
			if(rising_edge){
				state = ESTIMATING;
			}else{
				state = IDLE;
			}
			break;
		case ESTIMATING:
			counter_LEFT++;
			if(falling_edge){
				LEFT_VALUE = counter_LEFT;
				state = IDLE;
			}else{
				if(prev == 1 && current ==1){
					state = ESTIMATING;
				}
			}
			break;
	}
}


unsigned estimating_width_RIGHT(_Bool prev, _Bool current){
	static enum {IDLE, ESTIMATING} state = IDLE;
	_Bool rising_edge = (prev == 0 && current==1);
	_Bool falling_edge = ((prev == 1 && current==0));
	switch(state){
		case IDLE:
			counter_RIGHT=0;
			if(rising_edge){
				state = ESTIMATING;
			}else{
				state = IDLE;
			}
			break;
		case ESTIMATING:
			counter_RIGHT++;

			if(falling_edge){
				RIGHT_VALUE = counter_RIGHT;
				state = IDLE;
			}else{
				if(prev == 1 && current ==1){
					state = ESTIMATING;
				}
			}
			break;
	}
}

unsigned previous_Letter = U;
#define estimating_interval 100
int main(){
	print(" Hello \n");
	unsigned distance;
	unsigned prev_distance;

	unsigned position;
	_Bool right_coil;
	_Bool left_coil;
	_Bool prev_left_coil;
	_Bool prev_right_coil;
	unsigned cycle_count=0;
	unsigned left_coil_dips=0;
	unsigned right_coil_dips=0;
	_Bool start_estimating_left;
	_Bool start_estimating_right;
	unsigned left_coil_width;
	unsigned right_coil_width;
	unsigned down_counter = 500;

	_Bool JB0;
	_Bool prev_JB0;
	_Bool JB1;
	_Bool prev_JB1;
	int duty_L =10;
	int duty_R =10;

	unsigned prev_LEFT_VALUE;
	unsigned prev_RIGHT_VALUE;
	while(1){
		delay_us(200);
		JB0=JC34&1;
		JB1=(JC34>>1)&1;
		if(btn_pressed(btnL)){
			duty_L+=10;
		}

		if(btn_pressed(btnR)){
			duty_R+=10;
		}

		estimating_width_LEFT(prev_JB0, JB0);
		estimating_width_RIGHT(prev_JB1, JB1);

		if(prev_JB0 == 1 && JB0 == 0){
			left_coil_dips ++;
		}
		if(prev_JB1 == 1 && JB1 == 0){
			right_coil_dips ++;
		}

		if(data[0]!=previous_Letter){
			previous_Letter=data[0];
		}


		prev_RIGHT_VALUE = RIGHT_VALUE;
		detecting_object();
		data[1] == underscore;
		data[2]=(record_counter/10)%10;
		data[3]=(record_counter/1)%10;
		prev_JB0=JB0;
		prev_JB1=JB1;
		seg_disp(data,0);

		if(++cycle_count==estimating_interval){


			if((right_coil_dips==0 && left_coil_dips==0) ){

				data[0]=C;
			}else{
				if(right_coil_dips==0 && left_coil_dips!=0){

					data[0]=r;
				}

				if(right_coil_dips!=0 && left_coil_dips==0){

					data[0]=L;
				}

				if(right_coil_dips!=0 && left_coil_dips!=0){
					data[0]=U;

				}

			}


			cycle_count=0;
			right_coil_dips=0;
			left_coil_dips=0;

		}




		prev_right_coil=right_coil;
		prev_left_coil=left_coil;



	}

	if(record_counter)
}




void detecting_object(){
	static enum{ UNDETECTED, DETECTED} state = UNDETECTED;

	switch(state){
		case UNDETECTED:
			if(data[0] == U){
				state = UNDETECTED;
			}else{
				state=DETECTED;
			}
			break;
		case DETECTED:
			if(data[0]!=previous_Letter){
				record_counter++;
				state = UNDETECTED;
			}else{
				state = DETECTED;
			}
			break;

	}
}

void seg_disp(uint8_t data[4], uint8_t cursor)
{

    static uint16_t blink_cnt = 0;
    blink_cnt++;


    _Bool show_cursor = ((blink_cnt & 0x0100) == 0);

    static uint8_t digit = 0;


    AN = 0b1111;

    // Find the segment pattern for this digit, ignoring decimal for the moment:
    uint8_t pattern = disp_lut[ data[3 - digit] ];

    if(digit == 0 || digit == 2 || digit == 3 || digit == 1 ) {
        pattern |= 0b10000000;  // turn on decimal point in LSD
    }


    if( (cursor - 1) == digit ) {
        if(!show_cursor) {
            pattern = 0xff;
        }
    }

    // Write the pattern to the segment lines
    DPSEG = pattern;

    switch(digit) {
      case 0: AN = 0b1110; break;  // enable LSD
      case 1: AN = 0b1101; break;
      case 2: AN = 0b1011; break;
      case 3: AN = 0b0111; break;
    }

    // Move on to the next digit for next call
    digit = (digit + 1) & 0x03;
}
//
//
//void led_flasher(unsigned duty_int, unsigned duty_dec_point )
//{	unsigned duty=duty_int*10+duty_dec_point;
//	static uint16_t state=0;
//	if( state < duty) //
//		LEDS= 0xFFFF;
//	if( state >= duty)
//		LEDS = 0x0000;
//	if( ++state == 1000)
//		state =0;
//}
//
//
